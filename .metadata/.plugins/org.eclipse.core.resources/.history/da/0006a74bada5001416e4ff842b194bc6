package net.sdn.debugger;

/**
 * @author Tomasz Bak
 * @author Da Yu, Yiming Li
 */
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.Queue;

import net.sdn.packet.Packet;
import net.sdn.packet.PacketDeserializer;

import io.reactivex.netty.RxNetty;
import io.reactivex.netty.channel.ConnectionHandler;
import io.reactivex.netty.channel.ObservableConnection;
import io.reactivex.netty.pipeline.PipelineConfigurators;
import io.reactivex.netty.server.RxServer;
import rx.Notification;
import rx.Observable;
import rx.functions.Action0;
import rx.functions.Func1;

public class StatefulFirewallMonitorHandler implements Runnable {
	public void run() {
		createServer().startAndWait();
	}

	private final int port;
	// expectedEvents are events that expected to happened in the real network
	// generated by Oracle
	// based on the internal network state and the ideal model
	private Queue<String> expectedEvents = new LinkedList<String>();

	private static String lines = "";
	
	// lists for internal and external hosts
	private ArrayList<String> externalHosts = new ArrayList<String>();
	private ArrayList<String> internalHosts = new ArrayList<String>();
	//private ArrayList<> d
	
	private void loadInternalHosts(){
		internalHosts.add("10.0.0.1");
	}
	
	private void loadExternalHosts(){
		externalHosts.add("10.0.0.2");
	}

	public StatefulFirewallMonitorHandler(int port) {
		this.port = port;
		loadInternalHosts();
		loadExternalHosts();
		//this.initOracle();
	}

	public RxServer<String, String> createServer() {
		RxServer<String, String> server = RxNetty.createTcpServer(port,
				PipelineConfigurators.textOnlyConfigurator(),
				new ConnectionHandler<String, String>() {
					@Override
					public Observable<Void> handle(
							final ObservableConnection<String, String> connection) {
						System.out.println("Monitor connection established.");
						return connection
								.getInput()
								.flatMap(
										new Func1<String, Observable<Notification<Void>>>() {
											@Override
											public Observable<Notification<Void>> call(
													String msg) {
												// set filters:
												lines += msg;
												String temp[] = lines
														.split("\n");
												
												char[] chs = lines
														.toCharArray();		
												int count = 0;
												
												if (chs[chs.length - 1] == '\n') {
													// full message line
													count = temp.length;
													lines = "";
												} else {
													// part message line							
													count = temp.length - 1;
													lines = temp[temp.length - 1];
												}
												
													for (int i = 0; i < count; i++) {
														// get pkt
														// System.out.println(temp[i]);
														Packet pkt = PacketDeserializer.deserialize(temp[i]);
														
														// set filter
														if (pkt.nw_proto.equals("icmp") || pkt.of_type >= 0){
															Oracle(pkt);
														}*/

													}											

												return Observable.empty();
											}
										})
								.takeWhile(
										new Func1<Notification<Void>, Boolean>() {
											@Override
											public Boolean call(
													Notification<Void> notification) {
												return !notification.isOnError();
											}
										}).finallyDo(new Action0() {
									@Override
									public void call() {
										System.out.println(" --> Closing StatefulFireWall Monitor handler and stream");
									}
								}).map(new Func1<Notification<Void>, Void>() {
									@Override
									public Void call(
											Notification<Void> notification) {
										return null;
									}
								});
					}
				});

		System.out.println("StatefulFireWall Monitor handler started...");
		return server;
	}

	private void Oracle(Packet pkt) {
		// if packet is an OF13 message but it is a heartbeat, ignore.
		if (pkt.of_type >= 0 && (pkt.of_type == 2 || pkt.of_type == 3)){
			return;
		}

	}

	// Since in this test cases we know the behavior of the StatefulFirewall, we
	// can hard code
	private void initOracle() {
		this.expectedEvents.add("of_packet_in"); // arp request sent from h1
		this.expectedEvents.add("of_packet_out"); // arp response generated by
													// the
													// controller
		this.expectedEvents.add("Echo (ping) request"); // icmp ping request
														// sent
														// from h1 arrive at the
														// switch
		this.expectedEvents.add("of_packet_in"); // ping request was sent to the
													// controller
		this.expectedEvents.add("of_flow_add"); // flow_mod for the switches for
												// bidirections
		this.expectedEvents.add("of_flow_add"); // flow_mod for the switches for
												// bidirections
		this.expectedEvents.add("of_packet_out"); // ping request sent to the
													// controller before sent to
													// h2
		this.expectedEvents.add("Echo (ping) request"); // ping request sent
														// from
														// h1 reached h2
		this.expectedEvents.add("of_packet_in"); // arp request sent from h2
		this.expectedEvents.add("of_packet_out"); // arp response generated by
													// the
													// controller
		this.expectedEvents.add("Echo (ping) reply"); // ping reply arrive at
														// the
														// switch
		this.expectedEvents.add("Echo (ping) reply"); // ping reply arrive at
														// the
														// h1
		// afterward flow
		this.expectedEvents.add("Echo (ping) request"); // icmp ping request
														// sent
														// from h1 arrive at the
														// switch
		this.expectedEvents.add("Echo (ping) request"); // icmp ping request
														// sent
														// from h1 arrive at h2
		this.expectedEvents.add("Echo (ping) reply"); // ping reply arrive at
														// the
														// switch
		this.expectedEvents.add("Echo (ping) reply"); // ping reply arrive at
														// the
														// h1
	}
}
