package net.sdn.debugger;

/**
 * @author Tomasz Bak
 * @author Da Yu, Yiming Li
 */
import java.util.LinkedList;
import java.util.Queue;

import io.reactivex.netty.RxNetty;
import io.reactivex.netty.channel.ConnectionHandler;
import io.reactivex.netty.channel.ObservableConnection;
import io.reactivex.netty.pipeline.PipelineConfigurators;
import io.reactivex.netty.server.RxServer;
import rx.Notification;
import rx.Observable;
import rx.functions.Action0;
import rx.functions.Func1;

public class StatefulFirewallMonitorHandler implements Runnable {
	public void run() {
		createServer().startAndWait();
	}

	private final int port;
	// checkPoints is for test points that the Oracle will generate
	private Queue<String> checkPoints = new LinkedList<String>();
	// true - continue to testing, false - stop
	private boolean flag = true;

	public StatefulFirewallMonitorHandler(int port) {
		this.port = port;
		this.initOracle();
	}

	public RxServer<String, String> createServer() {
		RxServer<String, String> server = RxNetty.createTcpServer(port,
				PipelineConfigurators.textOnlyConfigurator(),
				new ConnectionHandler<String, String>() {
					@Override
					public Observable<Void> handle(
							final ObservableConnection<String, String> connection) {
						System.out.println("Monitor connection established.");
						return connection
								.getInput()
								.flatMap(
										new Func1<String, Observable<Notification<Void>>>() {
											@Override
											public Observable<Notification<Void>> call(
													String msg) {
												
												// set filters:
												String[] temp = msg.split("\n");
												for (String s: temp){
													//pipeline interested event to the Oracle
													if (s.contains("icmp") || s.contains("OF"))
														Oracle(s);
												}
												
												return Observable.empty();
											}
										})
								.takeWhile(
										new Func1<Notification<Void>, Boolean>() {
											@Override
											public Boolean call(
													Notification<Void> notification) {
												return !notification
														.isOnError();
											}
										}).finallyDo(new Action0() {
									@Override
									public void call() {
										System.out
												.println(" --> Closing StatefulFireWall Monitor handler and stream");
									}
								}).map(new Func1<Notification<Void>, Void>() {
									@Override
									public Void call(
											Notification<Void> notification) {
										return null;
									}
								});
					}
				});

		System.out.println("StatefulFireWall Monitor handler started...");
		return server;
	}
	
	private void Oracle(String pkt) {
		// maybe more than one lines
		String lines[] = pkt.split("\n");
		if (flag) {
			for (String line : lines) {
				if(line.contains("of_echo_request") || line.contains("of_echo_reply") || line.contains("Destination unreachable"))
					return;
				else {
					String assertion = this.checkPoints.peek();
					System.out.println("Oracle:" + assertion);
					if (!line.contains(assertion)){
						System.err.println("Oracle Failed!");
						flag = false;
					} else {
						System.out.println("Success");
						this.checkPoints.poll();
					}
				}
		
				if (this.checkPoints.size() == 0){
					System.out.println("All Tests are passed!");
					flag = false;
				}
			}
		}
	}
	
	// Since in this test cases we know the behavior of the StatefulFirewall, we can hard code
	private void initOracle(){
		this.checkPoints.add("of_packet_in"); // arp request sent from h1
		this.checkPoints.add("of_packet_out"); // arp response generated by the controller
		this.checkPoints.add("Echo (ping) request"); // icmp ping request sent from h1 arrive at the switch
		this.checkPoints.add("of_packet_in"); // ping request was sent to the controller
		this.checkPoints.add("of_flow_add"); // flow_mod for the switches for bidirections
		this.checkPoints.add("of_flow_add"); // flow_mod for the switches for bidirections
		this.checkPoints.add("of_packet_out"); // ping request sent to the controller before sent to h2
		this.checkPoints.add("Echo (ping) request"); // ping request sent from h1 reached h2
		this.checkPoints.add("of_packet_in"); // arp request sent from h2
		this.checkPoints.add("of_packet_out"); // arp response generated by the controller
		this.checkPoints.add("Echo (ping) reply"); // ping reply arrive at the switch
		this.checkPoints.add("Echo (ping) reply"); // ping reply arrive at the h1
		// afterward flow
		this.checkPoints.add("Echo (ping) request"); // icmp ping request sent from h1 arrive at the switch
		this.checkPoints.add("Echo (ping) request"); // icmp ping request sent from h1 arrive at h2
		this.checkPoints.add("Echo (ping) reply"); // ping reply arrive at the switch
		this.checkPoints.add("Echo (ping) reply"); // ping reply arrive at the h1
	}
}
